import { _computingFeliciaLanguage, _is, _getJSONParametersFromHtmlTag, _replaceTagWithDiv, _replaceTagById, _replaceTagDocumentByTagName, _contentToChart } from "../helper/felicia.js"; import { _addCircle } from "../geometry/circles.js"; export let _geojsonLayersGroup = []; let shapesRefract = [], stackHasCharts = []; const __addPointToShapes = (e, o, t) => { null == o ? shapesRefract.push(new t.marker(e.coordinates, { opacity: 1 })) : shapesRefract.push(new t.CircleMarker(e.coordinates, o)) }, __addPointIconToShapes = (e, o, t) => { if (null == o) shapesRefract.push(new t.marker(e.coordinates, { opacity: 1 })); else { let a = new t.icon(o); shapesRefract.push(new t.marker(e.coordinates, { icon: a })) } }, __addPolylineToShapes = (e, o, t) => { null == o ? shapesRefract.push(new t.Polyline(e.coordinates, { opacity: 1 })) : shapesRefract.push(new t.Polyline(e.coordinates, o)) }, __addPolygonToShapes = (e, o, t) => { null == o ? shapesRefract.push(new t.polygon(e.coordinates, { opacity: 1 })) : shapesRefract.push(new t.polygon(e.coordinates, o)) }; export const _addFromGeoJSONObjectArray = (e, o, t, a, i) => { for (var l of (shapesRefract = [], e)) { if (void 0 === l.type && !l.type instanceof String) return; if ("feature" !== l.type.toLowerCase()) return; if (void 0 === l.geometry) return; var r = l.geometry; if (void 0 === r.type && !r.type instanceof String) return; let e = null, n = void 0 === i || void 0 === i.graphic ? null : i.graphic; null === n && (e = void 0 === i || void 0 === i.icon ? null : i.icon); let s = null !== n ? n : e; "point" === r.type.toLowerCase() && void 0 === a ? (null === n && null !== s || (shapesRefract = [...shapesRefract, ..._addPoint(r, s, o, t)]), null !== e && (shapesRefract = [...shapesRefract, ..._addPointIcon(r, s, o, t)])) : "point" === r.type.toLowerCase() && void 0 !== a ? (null !== n && __addPointToShapes(r, s, t), null !== e && __addPointIconToShapes(r, s, t), null === s && (shapesRefract = _addPoint(r, s, o, t))) : "circle" === r.type.toLowerCase() && void 0 !== a ? null !== n && (shapesRefract = [...shapesRefract, ..._addCircle(r.coordinates, r.radius, s, o, t)]) : "circle" === r.type.toLowerCase() && void 0 === a ? shapesRefract = [...shapesRefract, ..._addCircle(r.coordinates, r.radius, s, o, t)] : "polyline" === r.type.toLowerCase() && void 0 === a ? shapesRefract = [...shapesRefract, ..._addPolyline(r, s, o, t)] : "polyline" === r.type.toLowerCase() && void 0 !== a ? __addPolylineToShapes(r, s, t) : "polygon" === r.type.toLowerCase() && void 0 === a ? shapesRefract = [...shapesRefract, ..._addPolygon(r, s, o, t)] : "polygon" === r.type.toLowerCase() && void 0 !== a && __addPolygonToShapes(r, n, t) } if (0 !== shapesRefract.length) { let e = t.layerGroup(shapesRefract); return e.addTo(o), e.type = a, _geojsonLayersGroup.push(e), { layer: e, name: a, shapes: [] } } }; export const _addFromGeoJSONObjectArrayOnSwitch = (e, o, t, a, i, l) => { shapesRefract = []; let r = void 0 !== t.default ? t.default : null, n = t.cases, s = Object.groupBy(e, (e => e.properties[t.fieldName])); if (Object.keys(s).map((e => ({ type: e, symbol: void 0 === n ? null : n.filter((o => -1 !== Object.keys(o).indexOf(e))).length > 0 ? n.filter((o => -1 !== Object.keys(o).indexOf(e)))[0][e] : r, geometries: s[e] }))).forEach((e => { const o = e.type; let t = e.symbol, a = null; const n = e.geometries; null !== e.symbol && "string" == typeof e.symbol.iconUrl && (a = e.symbol), null !== e.symbol && "string" == typeof e.symbol.radius && (t = e.symbol), t = null !== a ? null : t, n.forEach((e => { const n = e.geometry; "point" === n.type.toLowerCase() && void 0 === o ? (null !== t && (shapesRefract = [...shapesRefract, ..._addPoint(n, r, i, l)]), null !== a && (shapesRefract = [...shapesRefract, ..._addPointIcon(n, r, i, l)])) : "point" === n.type.toLowerCase() && void 0 !== o ? (null !== t && null === a && __addPointToShapes(n, t, l), null !== a && __addPointIconToShapes(n, a, l), null === t && null === a && (shapesRefract = _addPoint(n, r, i, l))) : "polyline" === n.type.toLowerCase() && void 0 === o ? shapesRefract = [...shapesRefract, ..._addPolyline(n, r, i, l)] : "polyline" === n.type.toLowerCase() && void 0 !== o ? __addPolylineToShapes(n, t, l) : "polygon" === n.type.toLowerCase() && void 0 === o ? shapesRefract = [...shapesRefract, ..._addPolygon(n, r, i, l)] : "polygon" === n.type.toLowerCase() && void 0 !== o ? __addPolygonToShapes(n, t, l) : "circle" === n.type.toLowerCase() && void 0 !== o && (shapesRefract = [...shapesRefract, ..._addCircle(n.coordinates, n.radius, null !== t ? t : r, i, l)]) })) })), 0 !== shapesRefract.length) { let e = l.layerGroup(shapesRefract); return e.addTo(i), e.type = o, _geojsonLayersGroup.push(e), { layer: e, name: o, shapes: shapesRefract } } }; const _toDiv = (e, o, t) => { let a = ""; return a = e.replace(`<${o}`, `<${t}`).replace(`></${o}>`, `></${t}>`), a }; export const _addFromGeoJSONObjectTooltipsFromArray = (e, o, t, a, i, l) => { let r = [0, 0], n = !0, s = 1; if (null == a) return; if (void 0 === a.content) return; void 0 !== a.offset && null !== a.offset && (r = a.offset), void 0 !== a.permanent && null !== a.permanent && (n = a.permanent), void 0 !== a.opacity && null !== a.opacity && (s = a.opacity); let p = []; for (let d of e) { if (void 0 === d.geometry) return; if (void 0 === d.geometry.coordinates) return; if ("point" === d.geometry.type.toLowerCase() || "circle" === d.geometry.type.toLowerCase()) { const e = d.properties; let y = _computingFeliciaLanguage(e, a.content); var c = t.tooltip(d.geometry.coordinates, { content: y, offset: r, permanent: n, opacity: s }).addTo(o.layer); l && _contentToChart(y), c.type = `tooltip_${i}`, p.push(c) } if ("polyline" === d.geometry.type.toLowerCase() || "polygon" === d.geometry.type.toLowerCase()) { const e = d.properties; let y = _computingFeliciaLanguage(e, a.content); (c = t.tooltip(t.polyline(d.geometry.coordinates).getBounds().getCenter(), { content: y, offset: r, permanent: n, opacity: s }).addTo(o.layer)).type = `tooltip_${i}`, p.push(c), l && _contentToChart(y) } } return { visibility: { type: `tooltip_${i}`, visibilityScales: a.visibilityZoomLevels }, tooltips: p } }; export const _addFromGeoJSON = (e, o, t) => _addFromGeoJSONObjectClass(e, o, t); export const _addFromGeoJSONString = (e, o, t, a) => { let i = null; try { i = JSON.parse(e) } catch (e) { console.error("Input file can't be parsed in JSON!"), console.error(e) } if (null !== i) return _addFromGeoJSONObjectClass(i, o, t, a) }; export const _addFromGeoJSONObjectClass = (e, o, t, a) => { Array.isArray(e) && (d = _addFromGeoJSONObjectArray(e, o, t, void 0, { graphic: void 0, icon: void 0 })); let i = null, l = null, r = null, n = null, s = null; if (void 0 === e.name && !e.name instanceof String) return; if (void 0 === e.data && !e.data instanceof Array) return; void 0 !== e.symbology && null !== e.symbology && void 0 !== e.symbology.color && (i = e.symbology), void 0 !== e.appearance && null !== e.appearance && void 0 !== e.appearance.color && (i = e.appearance), void 0 !== e.symbology && null !== e.symbology && void 0 !== e.symbology.iconUrl && (l = e.symbology), void 0 !== e.appearance && null !== e.appearance && void 0 !== e.appearance.iconUrl && (l = e.appearance), void 0 !== e.symbology && null !== e.symbology && void 0 !== e.symbology.switch && (r = e.symbology.switch), void 0 !== e.appearance && null !== e.appearance && void 0 !== e.appearance.switch && (r = e.appearance.switch), void 0 !== e.symbology && null !== e.symbology && void 0 !== e.symbology.visibilityZoomLevels && (n = e.symbology.visibilityZoomLevels), void 0 !== e.appearance && null !== e.appearance && void 0 !== e.appearance.visibilityZoomLevels && (n = e.appearance.visibilityZoomLevels), void 0 !== e.tooltip && null !== e.tooltip && (s = e.tooltip), null === s && void 0 !== e.appearance && null !== e.appearance && void 0 !== e.appearance.tooltip && (s = e.appearance.tooltip); let p = e.data, c = e.name, d = { layer: null, name: "", shapes: [] }; null === r && (d = _addFromGeoJSONObjectArray(p, o, t, c, { graphic: i, icon: l })), null !== r && (d = _addFromGeoJSONObjectArrayOnSwitch(p, e.name, r, 0, o, t)); let y = { visibility: { type: "", visibilityScales: {} }, tooltips: !1 }; const u = null !== s && _is(s.content, "chart"); stackHasCharts.push(u), y = _addFromGeoJSONObjectTooltipsFromArray(p, d, t, s, c, u); o.on("tooltipopen", (e => { a && -1 !== stackHasCharts.indexOf(!0) && void 0 !== e && void 0 !== e.tooltip && void 0 !== e.tooltip.options && void 0 !== e.tooltip.options.content && _is(e.tooltip.options.content, "chart") && _contentToChart(e.tooltip.options.content) })); let v = [], m = []; null !== i && (v = void 0 !== d ? [d.layer] : [], m = void 0 !== i.visibilityZoomLevels && null !== i.visibilityZoomLevels ? [{ visibilityScales: i.visibilityZoomLevels, type: c }] : []), null !== l && (v = void 0 !== d ? [d.layer] : [], m = void 0 !== l.visibilityZoomLevels && null !== l.visibilityZoomLevels ? [{ visibilityScales: l.visibilityZoomLevels, type: c }] : []), null !== r && (v = void 0 !== d ? [d.layer] : [], m = null === n ? [] : [{ type: c, visibilityScales: n }]); let h = void 0 !== y && void 0 !== y.tooltips && null !== y.tooltip ? y.tooltips : [], f = void 0 !== y && void 0 !== y.visibility && null !== y.visibility ? [y.visibility] : [], g = [...v, ...h], _ = [...m, ...f], b = { layer: null, name: null }; return null != d && (b = { layer: d.layer, name: d.name }), { overlay: b, settings: { shapes: g, visibility: _ } } }; const _addPoint = (e, o, t, a) => { let i = []; if (!(void 0 === e.coordinates && !e.coordinates instanceof Array)) { if (null === o) { var l = new a.marker(e.coordinates, { opacity: 1 }); i.push(l), l.addTo(t) } else { l = a.circleMarker(e.coordinates, o); i.push(l), l.addTo(t) } return i } }, _addPointIcon = (e, o, t, a) => { let i = []; if (!(void 0 === e.coordinates && !e.coordinates instanceof Array)) { if (null === o) { var l = new a.marker(e.coordinates, { opacity: 1 }); i.push(l), l.addTo(t) } else { let l = new a.icon(o), r = new a.marker(e.coordinates, { icon: l }); i.push(r), r.addTo(t) } return i } }, _addPolyline = (e, o, t, a) => { let i = []; if (!(void 0 === e.coordinates && !e.coordinates instanceof Array)) { if (null === o) { var l = new a.Polyline(e.coordinates, { opacity: 1 }); i.push(l), l.addTo(t) } else { l = new a.Polyline(e.coordinates, o); i.push(l), l.addTo(t) } return i } }, _addPolygon = (e, o, t, a) => { let i = []; if (!(void 0 === e.coordinates && !e.coordinates instanceof Array)) { if (null === o) { var l = new a.polygon(e.coordinates, { opacity: 1 }); i.push(l), l.addTo(t) } else { l = new a.polygon(e.coordinates, o); i.push(l), l.addTo(t) } return i } }; export const _hideContent = (e, o) => { void 0 === o || void 0 !== o && 0 === o.length ? _geojsonLayersGroup.map((o => { o.removeFrom(e) })) : _geojsonLayersGroup.map((t => { -1 !== o.indexOf(t.type) && t.removeFrom(e) })) }; export const _deleteAllGeoJSONFromMap = e => { _geojsonLayersGroup.map((e => { e.clearLayers() })) }; export const _deleteAllGeoJSONFromContent = e => { _geojsonLayersGroup.map((o => { o.removeFrom(e) })) };