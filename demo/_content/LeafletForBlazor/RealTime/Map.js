export function consoleLog(e) { console.log(e) } import { _addPoint, _addPointTooltip, _addPointCustomSymbology, _addPointCustomSymbologyAndTooltip, _addPointIcon, _addPointIconAndTooltip, _addPointFromArrayToMap, _deleteAllPointsFromArray, _setPointFromArrayCurrentSymbol, _addLabelPointFromArrayToMap, _deleteAllLabels } from "./geometry/point.js"; import { _initializationOfRendering, _settingsOfRendering, _settingsOfTooltips, _resetOfRendering, _emptyStreamPointCollection, _addPointToCollection, _addPointsToCollection, _addPointsOnType, _clearAllPointsCollection, _clearPointsByIdsCollection, _movePointFromCollection, _pointsLayersGroup, _updateAttribute, _settingDisplayCluster, _settingClusteringConfig } from "./geometry/points.js"; import { _addPolygonsArrayToMap, _setCurrentSymbol, _deleteAllPolygons } from "./geometry/polygons.js"; import { _addCircle, _deleteAllCircles } from "./geometry/circles.js"; import { _addMeasureArrayToMap, _addMeasureText, _addMeasureStyle, _addMeasureAnchor, _addRotate, _deleteAll, _calculateArrowLines, _deleteAllConnector } from "./geometry/polylines.js"; import { _route } from "./geometry/routing.js"; import { initBasemapLayers } from "./layers/basemap.js"; import { _setGeometricLayersVisibilityScale } from "./layers/geometricLayers.js"; import { _createSvgElement, _createSvgPieChart, _createSvgGaugeChart, _createSvgDonutChart, _clearMap, _clearPieChartMap } from "./layers/svg.js"; import { _addFromGeoJSONObjectArray, _addFromGeoJSONObjectClass, _geojsonLayersGroup, _addFromGeoJSON, _addFromGeoJSONString, _hideContent, _deleteAllGeoJSONFromMap } from "./geojson/fromObject.js"; import { _geocodeSearch, _reverseGeocode } from "./esri/geocoder.js"; let map = null, layers_control = null, LeafletCore = null; const config = { api: { src: "https://unpkg.com/leaflet@1.9.3/dist/leaflet.js", href: "https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" }, apiRotateMarker: { src: "https://unpkg.com/leaflet-rotatedmarker/leaflet.rotatedMarker.js" }, apiChart: { src: "https://cdn.jsdelivr.net/npm/chart.js" }, apiCluster: { src: "https://unpkg.com/leaflet.markercluster@1.3.0/dist/leaflet.markercluster.js", href1: "https://unpkg.com/leaflet.markercluster@1.3.0/dist/MarkerCluster.css", href2: "https://unpkg.com/leaflet.markercluster@1.3.0/dist/MarkerCluster.Default.css" }, apiHeatmap: { src: "https://cdn.jsdelivr.net/npm/leaflet.heat@0.2.0/dist/leaflet-heat.min.js" }, apiEsri: { src: "https://unpkg.com/esri-leaflet@3.0.16/dist/esri-leaflet.js" }, apiEsriVector: { src: "https://unpkg.com/esri-leaflet-vector@4.3.0/dist/esri-leaflet-vector.js" }, apiEsriGeocode: { src: "https://unpkg.com/esri-leaflet-geocoder@3.1.4/dist/esri-leaflet-geocoder.js", href: "https://unpkg.com/esri-leaflet-geocoder@3.1.4/dist/esri-leaflet-geocoder.css" }, apiRoutingMachine: { src: "https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js", href: "https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css" } }; let _dotNetObjRef = null; export const MapCoreInitialization = (e, t) => { _dotNetObjRef = e; const o = document.createElement("script"); o.src = config.api.src, o.async = !0; const a = document.createElement("script"); a.src = config.apiRotateMarker.src, a.async = !0; const n = document.createElement("link"); n.href = config.api.href, n.rel = "stylesheet"; const r = document.createElement("link"), l = document.createElement("script"); r.href = config.apiRoutingMachine.href, r.rel = "stylesheet", l.src = config.apiRoutingMachine.src, l.async = !0; const s = document.createElement("script"); s.src = config.apiChart.src, s.async = !0; const i = document.createElement("script"); i.src = config.apiCluster.src, i.async = !0; const d = document.createElement("link"); d.href = config.apiCluster.href1, d.rel = "stylesheet"; const c = document.createElement("link"); c.href = config.apiCluster.href2, c.rel = "stylesheet", document.body.appendChild(n), document.body.appendChild(o), document.body.appendChild(r), document.body.appendChild(l); const p = document.createElement("script"); p.src = config.apiEsri.src, p.async = !0; const m = document.createElement("script"); m.src = config.apiEsriVector.src, m.async = !0; const u = document.createElement("script"); u.src = config.apiEsriGeocode.src, u.async = !0; const g = document.createElement("link"); g.href = config.apiEsriGeocode.href, g.rel = "stylesheet"; let y = void 0 === t || void 0 === t.location || null === t.location || void 0 === t.location.longitude ? 0 : t.location.longitude, _ = void 0 === t || void 0 === t.location || null === t.location || void 0 === t.location.latitude ? 0 : t.location.latitude, C = {}; null != t && void 0 !== t.options && null !== t.options && void 0 !== t.options.interactionOptions && null !== t.options.interactionOptions && (C = t.options.interactionOptions), o.onload = () => { document.body.appendChild(a), document.body.appendChild(i), document.body.appendChild(d), document.body.appendChild(c), document.body.appendChild(p), document.body.appendChild(m), void 0 !== t.esriTasks && null !== t.esriTasks.geoSearch && document.body.appendChild(u), void 0 !== t.esriTasks && null !== t.esriTasks.reverseGeocode && document.body.appendChild(g), LeafletCore = L, map = L.map(t.__mapid, { doubleClickZoom: void 0 === C.doubleClickZoom || C.doubleClickZoom, shiftBoxZoom: void 0 === C.shiftBoxZoom || C.shiftBoxZoom, dragging: void 0 === C.dragging || C.dragging, trackResize: void 0 === C.trackResize || C.trackResize }).on("load", (function (t) { let o = t.target, a = o.getBounds(); e.invokeMethodAsync("onAfterMapLoaded", { zoomLevel: o._zoom, centerOfView: { latitude: o._lastCenter.lat, longitude: o._lastCenter.lng }, bounds: { northEast: { latitude: a._northEast.lat, longitude: a._northEast.lng }, southWest: { latitude: a._southWest.lat, longitude: a._southWest.lng } } }) })).setView({ lon: y, lat: _ }, t.zoom_level), layers_control = _layers_control(map), null !== layers_control && (p.onload = e => { m.onload = e => { initBasemapLayers(map, !1, t.basemap, layers_control, LeafletCore, t.apiKeys) } }), u.onload = () => { void 0 !== t.esriTasks && null !== t.esriTasks.geoSearch && _geocodeSearch(u, t.esriTasks.geoSearch, t.apiKeys.esriAPIKey, LeafletCore, map, _dotNetObjRef), void 0 !== t.esriTasks && null !== t.esriTasks.reverseGeocode && _reverseGeocode(u, t.apiKeys.esriAPIKey, LeafletCore, map, _dotNetObjRef) }, i.onload = e => { LeafletCore = L }, null !== t.map_scale && void 0 !== t.map_scale.has && !0 === t.map_scale.has && L.control.scale({ metric: t.map_scale.meters, imperial: t.map_scale.miles }).addTo(map), null !== t.defaultAttribution && void 0 !== t.defaultAttribution.has && void 0 !== t.defaultAttribution.defaultHtmlContent && (t.defaultAttribution.has ? "" !== t.defaultAttribution.defaultHtmlContent && map.attributionControl.setPrefix(t.defaultAttribution.defaultHtmlContent) : map.attributionControl.setPrefix(!1)), _setOnClickMapEvent(e), _setOnDoubleClickMapEvent(e), _setOnMouseDownMapEvent(e), _setOnMouseUpMapEvent(e), _setOnZoomLevelsChangeEvent(e), _setOnMouseMoveEvent(e), _setOnMousePanEvent(e) }, s.onload = e => { }, document.body.appendChild(s), o.onerror = () => { console.warn("Error occurred while loading Leaflet script") }, s.onerror = () => { console.warn("Error occurred while loading Chart script") }, p.onerror = e => { console.log(e) }, m.onerror = e => { console.log(e) } }; export const _setOnClickMapEvent = e => { map.on("click", (t => { e.invokeMethodAsync("onClickingMap", { location: { latitude: t.latlng.lat, longitude: t.latlng.lng } }) })) }; export const _setOnDoubleClickMapEvent = e => { map.on("dblclick", (t => { e.invokeMethodAsync("onDoubleClickingMap", { location: { latitude: t.latlng.lat, longitude: t.latlng.lng } }) })) }; export const _setOnMouseDownMapEvent = e => { map.on("mousedown", (t => { e.invokeMethodAsync("onMouseDownMap", { location: { latitude: t.latlng.lat, longitude: t.latlng.lng } }) })) }; export const _setOnMouseUpMapEvent = e => { map.on("mouseup", (t => { e.invokeMethodAsync("onMouseUpMap", { location: { latitude: t.latlng.lat, longitude: t.latlng.lng } }) })) }; export const _setOnZoomLevelsChangeEvent = e => { map.on("zoomend", (t => { e.invokeMethodAsync("onZoomLevelEndChange", { centerOfView: { latitude: t.sourceTarget._lastCenter.lat, longitude: t.sourceTarget._lastCenter.lng }, zoomLevel: t.sourceTarget._zoom }) })) }; export const _setOnMouseMoveEvent = e => { map.on("mousemove", (t => { e.invokeMethodAsync("onMouseMove", { location: { latitude: t.latlng.lat, longitude: t.latlng.lng } }) })) }; export const _setOnMousePanEvent = e => { map.on("move", (t => { var o = t.target, a = t.target.getBounds(); null !== o._lastCenter && e.invokeMethodAsync("onPanMap", { zoomLevel: o.getZoom(), centerOfView: { latitude: o._lastCenter.lat, longitude: o._lastCenter.lng }, bounds: { northEast: { latitude: a._northEast.lat, longitude: a._northEast.lng }, southWest: { latitude: a._southWest.lat, longitude: a._southWest.lng } } }) })) }; const _layers_control = e => L.control.layers(null, null, { collapsed: !0 }).addTo(e); export const setGeometricLayersVisibilityScale = e => { _setGeometricLayersVisibilityScale(_pointsLayersGroup, e, map, LeafletCore) }; export const setZoom = e => { map.setZoom(e) }; export const setCenterOfView = e => { let t = LeafletCore.latLng(e.latitude, e.longitude); map.setView(t) }; export const setBoundsOfView = e => { let t = LeafletCore.latLngBounds(LeafletCore.latLng(e.northEast.latitude, e.northEast.longitude), LeafletCore.latLng(e.southWest.latitude, e.southWest.longitude)); map.fitBounds(t) }; export const setMinZoomLevel = e => { map.setMinZoom(e) }; export const setMaxZoomLevel = e => { map.setMaxZoom(e) }; export const addPoint = e => { _addPoint(e, map, LeafletCore) }; export const addPointTooltip = e => { _addPointTooltip(e, map, LeafletCore) }; export const addPointCustomSymbology = e => { _addPointCustomSymbology(e, map, LeafletCore) }; export const addPointCustomSymbologyAndTooltip = e => { _addPointCustomSymbologyAndTooltip(e, map, LeafletCore) }; export const addPointIcon = e => { _addPointIcon(e, map, LeafletCore) }; export const addPointIconAndTooltip = e => { _addPointIconAndTooltip(e, map, LeafletCore) }; export const addPointFromArrayToMap = e => { _addPointFromArrayToMap(e, map, LeafletCore) }; export const deleteAllPointsFromArray = () => { _deleteAllPointsFromArray(map, LeafletCore) }; export const setPointFromArrayCurrentSymbol = e => { _setPointFromArrayCurrentSymbol(e) }; export const setDisplayCluster = e => { _settingDisplayCluster(e) }; export const setClusteringConfig = e => { _settingClusteringConfig(e) }; export const route = e => { _route(e, map, LeafletCore, _dotNetObjRef) }; export const addLabelPointFromArrayToMap = e => { _addLabelPointFromArrayToMap(e, map, LeafletCore) }; export const deleteAllLabels = () => { _deleteAllLabels(map) }; export const initializationOfRendering = e => { _initializationOfRendering(e) }; export const settingsOfRendering = e => { const t = _settingsOfRendering(e, LeafletCore); void 0 !== t && onAppearanceChange(t.symbols) }; export const onAppearanceChange = e => { const t = [...e.filter((e => 0 !== e.guids.length))]; _dotNetObjRef.invokeMethodAsync("onStreamPointAppearanceChange", t) }; export const settingsOfTooltips = e => { 0 !== e.length && _settingsOfTooltips(e, map) }; export const resetOfRendering = () => { _resetOfRendering() }; export const addPointToStreamCollection = e => { _addPointToCollection(e, map, LeafletCore) }; export const addPointsToStreamCollection = e => { const t = _addPointsToCollection(e, !1, map, LeafletCore, _dotNetObjRef); onPointStreamsAdd(t.renderingPointCollection), null !== t.layer && 0 === Object.values(layers_control._layers).filter((e => e.name === t.layer.type)).length && layers_control.addOverlay(t.layer, t.layer.type) }; export const onPointStreamsAdd = e => { _dotNetObjRef.invokeMethodAsync("onPointStreamAdd", []) }; export const addNewPointsToStreamCollection = e => { _addPointsToCollection(e, !0, map, LeafletCore) }; export const addPointsOnType = e => { _addPointsOnType(e, !1, map, LeafletCore) }; export const addNewCollectionPointsOnType = e => { _addPointsOnType(e, !0, map, LeafletCore) }; export const emptyStreamPointCollection = () => { _emptyStreamPointCollection() }; export const updateAttribute = e => { const t = _updateAttribute(e, map, LeafletCore); if (onAppearanceChange(t.symbols), null !== t.layers && 0 !== t.layers.length) for (let e of t.layers) 0 === Object.values(layers_control._layers).filter((t => t.name === e.type)).length && layers_control.addOverlay(e, e.type) }; export const addPolygonsArrayToMap = e => { _addPolygonsArrayToMap(e, map, LeafletCore) }; export const setCurrentSymbol = e => { _setCurrentSymbol(e) }; export const deleteAllPolygons = () => { _deleteAllPolygons(map) }; export const addCircle = e => { _addCircle(e.coordinate, e.radius, e.symbol, map, LeafletCore) }; export const deleteAllCircles = () => { _deleteAllCircles(map) }; export const addRotate = e => { _addRotate(e) }; export const addMeasureText = e => { _addMeasureText(e) }; export const addMeasureStyle = e => { _addMeasureStyle(e) }; export const addMeasureAnchor = e => { _addMeasureAnchor(e) }; export const deleteAll = () => { _deleteAll(map) }; export const addMeasureLineFromArray = e => { _addMeasureArrayToMap(e, map, LeafletCore) }; export const addDirection = e => { _calculateArrowLines(JSON.parse(e.polyline), e.start, e.radianAngle, e.length, e.symbol, map, LeafletCore) }; export const deleteAllConnector = () => { _deleteAllConnector(map) }; export const clearAllStreamCollection = () => { _clearAllPointsCollection(map) }; export const clearPointsByIdsStreamCollection = e => { _clearPointsByIdsCollection(e, map) }; export const movePointFromStreamCollection = e => { _movePointFromCollection(e, map, LeafletCore) }; export const setExtent = e => { let t = LeafletCore.latLng(e.latmin, e.lngmin), o = LeafletCore.latLng(e.latmax, e.lngmax), a = L.latLngBounds(t, o); map.fitBounds(a) }; export const createSvgElement = e => { _createSvgElement(e, map, LeafletCore) }; export const createPieChartPoint = e => { _createSvgPieChart(e, map, LeafletCore) }; export const createGaugeChartPoint = e => { _createSvgGaugeChart(e, map, LeafletCore) }; export const createSvgDonutChart = e => { _createSvgDonutChart(e, map, LeafletCore) }; export const clearMap = () => { _clearMap(map, LeafletCore) }; export const clearPieChartMap = () => { console.log(""), _clearPieChartMap(map, LeafletCore) }; export const addFromGeoJSONObjectArray = e => { _addFromGeoJSONObjectArray(e, map, LeafletCore) }; export const addFromGeoJSONObjectClass = e => { let t = _addFromGeoJSON(e, map, LeafletCore); void 0 !== t && void 0 !== t.overlay && null !== t.overlay && void 0 !== t.overlay.name && void 0 !== t.overlay.layer && layers_control.addOverlay(t.overlay.layer, t.overlay.name), setGeoJSONLayersVisibilityScale(t.settings.visibility, t.settings.shapes) }; export const addFromGeoJSONString = e => { let t = _addFromGeoJSONString(e.content, map, LeafletCore, e.isLast); return void 0 !== t && void 0 !== t.overlay && null !== t.overlay && void 0 !== t.overlay.name && void 0 !== t.overlay.layer && layers_control.addOverlay(t.overlay.layer, t.overlay.name), setGeoJSONLayersVisibilityScale(t.settings.visibility, t.settings.shapes), resut.overlay.name }; export const setGeoJSONLayersVisibilityScale = (e, t) => { _setGeometricLayersVisibilityScale(t, e, map, LeafletCore) }; export const hideContent = e => { null !== e && Array.isArray(e) && e.length, _hideContent(map, e) }; export const closeTooltips = () => { }; export const deleteAllGeoJSONFromMap = () => { _deleteAllGeoJSONFromMap(map) }; export const addAttribution = e => { map.attributionControl.addAttribution(e) }; export const removeAttribution = e => { map.attributionControl.removeAttribution(e) };