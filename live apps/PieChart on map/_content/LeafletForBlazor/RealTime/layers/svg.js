import { newLatitudeLongitude, distance } from "../helper/mathFelicia.js"; let svgLayers = [], zoomEvents = [], moveEvents = [], pieChartLayers = [], zoomEventsPieCharts = [], moveEventsPieCharts = []; Array.prototype.removeSVG = function (t) { for (let e = 0; e < this.length; e++)this[e]._leaflet_id === t && this.splice(e, 1) }; export const _createSvgElement = (t, e, o) => { let l = null, a = !1, i = null, n = null; i = e.on("zoomend", (i => { var n = i.target._zoom; let s = i.target.getBounds(); null !== l && (e.removeLayer(l), svgLayers.removeSVG(l._leaflet_id)); let r = t.location.latitude >= s._southWest.lat && t.location.longitude >= s._southWest.lng && t.location.latitude <= s._northEast.lat && t.location.longitude <= s._northEast.lng; (null === t.visibilityZoomLevel && r || null !== t.visibilityZoomLevel && t.visibilityZoomLevel.minZoomLevel <= n && t.visibilityZoomLevel.maxZoomLevel >= n && r) && (l = _draw(t, l, n, e, o), svgLayers.push(l)), a = !0 })), zoomEvents.push(i), n = e.on("move", (a => { let i = a.target._zoom; null !== l && (e.removeLayer(l), svgLayers.removeSVG(l._leaflet_id)); var n = a.target.getBounds(); let s = t.location.latitude >= n._southWest.lat && t.location.longitude >= n._southWest.lng && t.location.latitude <= n._northEast.lat && t.location.longitude <= n._northEast.lng; (s && null !== t.visibilityZoomLevel && t.visibilityZoomLevel.minZoomLevel <= i && t.visibilityZoomLevel.maxZoomLevel >= i || s && null === t.visibilityZoomLevel) && (l = _draw(t, l, e.getZoom(), e, o), svgLayers.push(l)) })), moveEvents.push(n); let s = e.getBounds(); t.location.latitude >= s._southWest.lat && t.location.longitude >= s._southWest.lng && t.location.latitude <= s._northEast.lat && t.location.longitude <= s._northEast.lng && (l = _draw(t, l, e.getZoom(), e, o), svgLayers.push(l)) }; export const _createSvgPieChart = (t, e, o) => { let l = null, a = !1, i = null, n = null; i = e.on("zoomend", (i => { var n = i.target._zoom; let s = i.target.getBounds(); null !== l && (e.removeLayer(l), pieChartLayers.removeSVG(l._leaflet_id)); let r = t.location.latitude >= s._southWest.lat && t.location.longitude >= s._southWest.lng && t.location.latitude <= s._northEast.lat && t.location.longitude <= s._northEast.lng; (null === t.visibilityZoomLevel && r || null !== t.visibilityZoomLevel && t.visibilityZoomLevel.minZoomLevel <= n && t.visibilityZoomLevel.maxZoomLevel >= n && r) && (l = _drawPieChart(t, l, n, e, o), pieChartLayers.push(l)), a = !0 })), zoomEventsPieCharts.push(i), n = e.on("move", (a => { let i = a.target._zoom; null !== l && (e.removeLayer(l), pieChartLayers.removeSVG(l._leaflet_id)); var n = a.target.getBounds(); let s = t.location.latitude >= n._southWest.lat && t.location.longitude >= n._southWest.lng && t.location.latitude <= n._northEast.lat && t.location.longitude <= n._northEast.lng; (s && null !== t.visibilityZoomLevel && t.visibilityZoomLevel.minZoomLevel <= i && t.visibilityZoomLevel.maxZoomLevel >= i || s && null === t.visibilityZoomLevel) && (l = _drawPieChart(t, l, e.getZoom(), e, o), pieChartLayers.push(l)) })), moveEventsPieCharts.push(n); let s = e.getBounds(); t.location.latitude >= s._southWest.lat && t.location.longitude >= s._southWest.lng && t.location.latitude <= s._northEast.lat && t.location.longitude <= s._northEast.lng && (l = _drawPieChart(t, l, e.getZoom(), e, o), pieChartLayers.push(l)) }; export const _createSvgDonutChart = (t, e, o) => { let l = null, a = !1, i = null, n = null; i = e.on("zoomend", (i => { var n = i.target._zoom; let s = i.target.getBounds(); null !== l && (e.removeLayer(l), pieChartLayers.removeSVG(l._leaflet_id)); let r = t.location.latitude >= s._southWest.lat && t.location.longitude >= s._southWest.lng && t.location.latitude <= s._northEast.lat && t.location.longitude <= s._northEast.lng; (null === t.visibilityZoomLevel && r || null !== t.visibilityZoomLevel && t.visibilityZoomLevel.minZoomLevel <= n && t.visibilityZoomLevel.maxZoomLevel >= n && r) && (l = _drawDonutChart(t, l, n, e, o), pieChartLayers.push(l)), a = !0 })), zoomEventsPieCharts.push(i), n = e.on("move", (a => { let i = a.target._zoom; null !== l && (e.removeLayer(l), pieChartLayers.removeSVG(l._leaflet_id)); var n = a.target.getBounds(); let s = t.location.latitude >= n._southWest.lat && t.location.longitude >= n._southWest.lng && t.location.latitude <= n._northEast.lat && t.location.longitude <= n._northEast.lng; (s && null !== t.visibilityZoomLevel && t.visibilityZoomLevel.minZoomLevel <= i && t.visibilityZoomLevel.maxZoomLevel >= i || s && null === t.visibilityZoomLevel) && (l = _drawDonutChart(t, l, e.getZoom(), e, o), pieChartLayers.push(l)) })), moveEventsPieCharts.push(n); let s = e.getBounds(); t.location.latitude >= s._southWest.lat && t.location.longitude >= s._southWest.lng && t.location.latitude <= s._northEast.lat && t.location.longitude <= s._northEast.lng && (l = _drawDonutChart(t, l, e.getZoom(), e, o), pieChartLayers.push(l)) }; export const _createSvgGaugeChart = (t, e, o) => { let l = null, a = !1, i = null, n = null; i = e.on("zoomend", (i => { var n = i.target._zoom; let s = i.target.getBounds(); null !== l && (e.removeLayer(l), pieChartLayers.removeSVG(l._leaflet_id)); let r = t.location.latitude >= s._southWest.lat && t.location.longitude >= s._southWest.lng && t.location.latitude <= s._northEast.lat && t.location.longitude <= s._northEast.lng; (null === t.visibilityZoomLevel && r || null !== t.visibilityZoomLevel && t.visibilityZoomLevel.minZoomLevel <= n && t.visibilityZoomLevel.maxZoomLevel >= n && r) && (l = _drawGaugeChart(t, l, n, e, o), pieChartLayers.push(l)), a = !0 })), zoomEventsPieCharts.push(i), n = e.on("move", (a => { let i = a.target._zoom; null !== l && (e.removeLayer(l), pieChartLayers.removeSVG(l._leaflet_id)); var n = a.target.getBounds(); let s = t.location.latitude >= n._southWest.lat && t.location.longitude >= n._southWest.lng && t.location.latitude <= n._northEast.lat && t.location.longitude <= n._northEast.lng; (s && null !== t.visibilityZoomLevel && t.visibilityZoomLevel.minZoomLevel <= i && t.visibilityZoomLevel.maxZoomLevel >= i || s && null === t.visibilityZoomLevel) && (l = _drawGaugeChart(t, l, e.getZoom(), e, o), pieChartLayers.push(l)) })), moveEventsPieCharts.push(n); let s = e.getBounds(); t.location.latitude >= s._southWest.lat && t.location.longitude >= s._southWest.lng && t.location.latitude <= s._northEast.lat && t.location.longitude <= s._northEast.lng && (l = _drawGaugeChart(t, l, e.getZoom(), e, o), pieChartLayers.push(l)) }; export const _clearMap = (t, e) => { svgLayers.forEach((e => { t.removeLayer(e) })), zoomEvents.forEach((e => { t.off("zoomend") })), moveEvents.forEach((e => { t.off("move") })) }; export const _clearPieChartMap = (t, e) => { pieChartLayers.forEach((e => { t.removeLayer(e) })), zoomEventsPieCharts.forEach((e => { t.off("zoomend") })), moveEventsPieCharts.forEach((e => { t.off("move") })) }; const _draw = (t, e, o, l, a) => { var i = t.htmlContent; const n = l.getBounds(), s = { start: { latitude: n._northEast.lat, longitude: n._northEast.lng }, stop: { latitude: n._southWest.lat, longitude: n._southWest.lng } }, r = _distanceForScalling(s, o, t.dimension), u = t.scaling, d = t.scaling; var c = document.createElementNS("http://www.w3.org/2000/svg", "svg"); c.setAttribute("xmlns", "http://www.w3.org/2000/svg"), c.setAttribute("viewBox", `0 0 ${u} ${d}`), c.innerHTML = `<svg height="${u}" width="${d}" xmlns="http://www.w3.org/2000/svg">${i}</svg>`; const h = _rectangleCoords(t.location.latitude, t.location.longitude, r); var g = [[h.start.latitude, h.start.longitude], [h.stop.latitude, h.stop.longitude]]; return a.svgOverlay(c, g).addTo(l) }, _drawPieChart = (t, e, o, l, a) => { const i = l.getBounds(), n = { start: { latitude: i._northEast.lat, longitude: i._northEast.lng }, stop: { latitude: i._southWest.lat, longitude: i._southWest.lng } }, s = _distanceForScalling(n, o, t.dimension); t.scaling, t.scaling; var r = _createPieChartSVG({ values: t.values, colors: t.colors, labels: t.labels, fontSize: t.fontSize, expandedIndex: t.expandedIndex, styles: t.styles }); const u = _rectangleCoords(t.location.latitude, t.location.longitude, s); var d = [[u.start.latitude, u.start.longitude], [u.stop.latitude, u.stop.longitude]]; return a.svgOverlay(r, d).addTo(l) }, _drawDonutChart = (t, e, o, l, a) => { const i = l.getBounds(), n = { start: { latitude: i._northEast.lat, longitude: i._northEast.lng }, stop: { latitude: i._southWest.lat, longitude: i._southWest.lng } }, s = _distanceForScalling(n, o, t.dimension); t.scaling, t.scaling; var r = _createDonutChartSVG({ values: t.values, colors: t.colors, labels: t.labels, heightCircularCrown: t.heightCircularCrown, expandedIndex: t.expandedIndex, fontSize: t.fontSize, styles: t.styles }); const u = _rectangleCoords(t.location.latitude, t.location.longitude, s); var d = [[u.start.latitude, u.start.longitude], [u.stop.latitude, u.stop.longitude]]; return a.svgOverlay(r, d).addTo(l) }, _drawGaugeChart = (t, e, o, l, a) => { const i = l.getBounds(), n = { start: { latitude: i._northEast.lat, longitude: i._northEast.lng }, stop: { latitude: i._southWest.lat, longitude: i._southWest.lng } }, s = _distanceForScalling(n, o, t.dimension), r = (t.scaling, t.scaling, _createGaugeSVG({ valueStart: t.valueStart, valueStop: t.valueStop, value: t.value, label: t.label, colorStart: t.colorStart, colorStop: t.colorStop, opacity: t.opacity, heightCircularCrown: t.heightCircularCrown, urlIndicator: t.urlIndicator, fontColorStart: t.fontColorStart, fontColorMiddle: t.fontColorMiddle, fontColorStop: t.fontColorStop, fontSize: t.fontSize, gaugeIndex: t.gaugeIndex, styles: t.styles, turnedAround: t.turnedAround })), u = _rectangleCoords(t.location.latitude, t.location.longitude, s); var d = [[u.start.latitude, u.start.longitude], [u.stop.latitude, u.stop.longitude]]; return a.svgOverlay(r, d).addTo(l) }, _distanceForScalling = (t, e, o) => { const l = -4 / 18 * e + 18; return distance(t) / l * o / 28 }, _rectangleCoords = (t, e, o) => { const l = newLatitudeLongitude(t, e, o / 2, "S"), a = newLatitudeLongitude(l.latitude, l.longitude, o / 2, "W"), i = newLatitudeLongitude(t, e, o / 2, "N"), n = newLatitudeLongitude(i.latitude, i.longitude, o / 2, "E"); return { start: { latitude: a.latitude, longitude: a.longitude }, stop: { latitude: n.latitude, longitude: n.longitude } } }, _createPieChartSVG = ({ values: t, colors: e, labels: o, expandedIndex: l = null, expandOffset: a = 8, fontSize: i = 6, styles: n = null }) => { const s = "http://www.w3.org/2000/svg", r = 40, u = 50, d = t.reduce(((t, e) => t + e), 0), c = document.createElementNS(s, "svg"); c.setAttribute("viewBox", "0 0 100 100"), c.setAttribute("width", "100"), c.setAttribute("height", "100"); let h = -90; return t.forEach(((t, g) => { const v = t / d * 360, m = h + v, b = (h + m) / 2, p = t => t * Math.PI / 180, _ = g === l, y = _ ? a * Math.cos(p(b)) : 0, C = _ ? a * Math.sin(p(b)) : 0, L = u + r * Math.cos(p(h)) + y, A = u + r * Math.sin(p(h)) + C, f = u + r * Math.cos(p(m)) + y, E = u + r * Math.sin(p(m)) + C, x = v > 180 ? 1 : 0, S = document.createElementNS(s, "path"); S.setAttribute("d", `\n            M ${u + y} ${u + C}\n            L ${L} ${A}\n            A 40 40 0 ${x} 1 ${f} ${E}\n            Z\n            `), S.setAttribute("fill", e[g]), c.appendChild(S), null != n && null !== n.slice && void 0 !== n.slice && n.slice.attributes.forEach((t => { S.setAttribute(t.name, t.value) })); const w = u + 24 * Math.cos(p(b)) + y, Z = u + 24 * Math.sin(p(b)) + C, $ = document.createElementNS(s, "text"); $.setAttribute("x", w), $.setAttribute("y", Z), $.setAttribute("text-anchor", "middle"), $.setAttribute("dominant-baseline", "middle"), $.setAttribute("font-size", i), $.setAttribute("fill", _getComplementaryColor(e[g])), $.textContent = o[g], null != n && null !== n.label && void 0 !== n.label && n.label.attributes.forEach((t => { $.setAttribute(t.name, t.value) })), c.appendChild($), h = m })), c }, _createDonutChartSVG = ({ values: t, colors: e, labels: o, heightCircularCrown: l, expandedIndex: a = null, expandOffset: i = 5, fontSize: n = 6, styles: s = null }) => { const r = "http://www.w3.org/2000/svg", u = 45, d = u - l, c = t.reduce(((t, e) => t + e), 0), h = document.createElementNS(r, "svg"); h.setAttribute("viewBox", "0 0 100 100"), h.setAttribute("width", "100"), h.setAttribute("height", "100"); let g = -90; const v = t => t * Math.PI / 180, m = (t, e) => ({ x: 50 + t * Math.cos(v(e)), y: 50 + t * Math.sin(v(e)) }); return t.forEach(((t, l) => { const b = t / c * 360, p = g + b, _ = (g + p) / 2, y = l === a, C = y ? i * Math.cos(v(_)) : 0, L = y ? i * Math.sin(v(_)) : 0, A = m(u, g), f = m(u, p), E = m(d, p), x = m(d, g), S = b > 180 ? 1 : 0, w = document.createElementNS(r, "path"); w.setAttribute("d", `\n            M ${A.x + C} ${A.y + L}\n            A 45 45 0 ${S} 1 ${f.x + C} ${f.y + L}\n            L ${E.x + C} ${E.y + L}\n            A ${d} ${d} 0 ${S} 0 ${x.x + C} ${x.y + L}\n            Z\n            `), w.setAttribute("fill", e[l]), null != s && null !== s.slice && void 0 !== s.slice && s.slice.attributes.forEach((t => { w.setAttribute(t.name, t.value) })), h.appendChild(w); const Z = m((u + d) / 2, _), $ = document.createElementNS(r, "text"); $.setAttribute("x", Z.x + C), $.setAttribute("y", Z.y + L), $.setAttribute("text-anchor", "middle"), $.setAttribute("dominant-baseline", "middle"), $.setAttribute("font-size", "4"), $.setAttribute("fill", _getComplementaryColor(e[l])), $.setAttribute("font-size", n), $.textContent = o[l], null != s && null !== s.label && void 0 !== s.label && s.label.attributes.forEach((t => { $.setAttribute(t.name, t.value) })), h.appendChild($), g = p })), h }; function _createGaugeSVG({ valueStart: t, valueStop: e, value: o, label: l, colorStart: a, colorStop: i, opacity: n = "1", heightCircularCrown: s, urlIndicator: r = null, fontColorStart: u = "black", fontColorMiddle: d = "black", fontColorStop: c = "black", fontSize: h = 5, gaugeIndex: g = 0, styles: v = null, turnedAround: m = !0 }) { const b = "http://www.w3.org/2000/svg", p = 50, _ = 50, y = 45, C = y - s; var L, A, f; L = o, A = t, f = e; const E = 180 * (((o = Math.min(f, Math.max(A, L))) - t) / (e - t)) - 180, x = (t + e) / 2, S = (t, e) => { const o = e * Math.PI / 180; return { x: p + t * Math.cos(o), y: _ + t * Math.sin(o) } }, w = document.createElementNS(b, "svg"); w.setAttribute("viewBox", "0 0 100 100"), w.setAttribute("width", "100"), w.setAttribute("height", "100"); const Z = document.createElementNS(b, "path"), $ = (t, e) => { const o = e * Math.PI / 180; return { x: 50 + t * Math.cos(o), y: 50 + t * Math.sin(o) } }, z = $(45, m ? 0 : -180), W = $(45, m ? 180 : 0), M = `\n    M 50 50\n    L ${z.x} ${z.y}\n    A 45 45 0 0 1 ${W.x} ${W.y}\n    Z\n`; Z.setAttribute("d", M), Z.setAttribute("fill", "white"), Z.setAttribute("fill-opacity", n), Z.setAttribute("stroke-width", "1px"), null != v && null !== v.panel && void 0 !== v.panel && v.panel.attributes.forEach((t => { Z.setAttribute(t.name, t.value) })); const G = document.createElementNS(b, "defs"), B = document.createElementNS(b, "linearGradient"); B.setAttribute("id", `gaugeGradient${g}`), B.setAttribute("x1", "0%"), B.setAttribute("y1", "0%"), B.setAttribute("x2", "100%"), B.setAttribute("y2", "0%"); const P = document.createElementNS(b, "stop"); P.setAttribute("offset", "0%"), P.setAttribute("stop-color", a); const I = document.createElementNS(b, "stop"); I.setAttribute("offset", "100%"), I.setAttribute("stop-color", i), B.appendChild(P), B.appendChild(I), G.appendChild(B), w.appendChild(G); const N = S(y, m ? 0 : 180), V = S(y, m ? 180 : 0), k = S(C, m ? 180 : 0), D = S(C, m ? 0 : 180), T = `\n        M ${N.x} ${N.y}\n        A 45 45 0 0 1 ${V.x} ${V.y}\n        L ${k.x} ${k.y}\n        A ${C} ${C} 0 0 0 ${D.x} ${D.y}\n        Z\n    `, F = document.createElementNS(b, "path"); F.setAttribute("d", T), F.setAttribute("fill", `url(#gaugeGradient${g})`), F.setAttribute("stroke", "black"), F.setAttribute("stroke-width", "0.3"), F.setAttribute("fill-opacity", n), null != v && null !== v.crown && void 0 !== v.crown && v.crown.attributes.forEach((t => { F.setAttribute(t.name, t.value) })); const O = (y + C) / 2; w.appendChild(Z), w.appendChild(F); const R = (t, e, o, l = "black", a = 4) => { const i = S(e, o), n = document.createElementNS(b, "text"); return n.setAttribute("x", i.x), n.setAttribute("y", i.y), n.setAttribute("text-anchor", "middle"), n.setAttribute("dominant-baseline", "middle"), n.setAttribute("font-size", a), n.setAttribute("fill", l), n.textContent = t, w.appendChild(n), n }; R(t, O, m ? 10 : -170, u, h), R(x, O, m ? 90 : -90, d, h), R(e, O, m ? 170 : -10, c, h); const j = R(o, (m ? -1 : 1) * (O - 28), -90, 6, "black"), H = R(l, (m ? -1 : 1) * (O - O / 2), -90, 4, "black"); null != v && null !== v.gaugeValue && void 0 !== v.gaugeValue && v.gaugeValue.attributes.forEach((t => { j.setAttribute(t.name, t.value) })), null != v && null !== v.gaugeLabel && void 0 !== v.gaugeLabel && v.gaugeLabel.attributes.forEach((t => { H.setAttribute(t.name, t.value) })); const q = document.createElementNS(b, "g"); if (q.setAttribute("transform", `rotate(${E + 90} 50 50)`), r) { const t = document.createElementNS(b, "image"); t.setAttribute("href", r), t.setAttribute("x", 48), t.setAttribute("y", 5), t.setAttribute("width", 4), t.setAttribute("height", y), q.appendChild(t) } else { const t = document.createElementNS(b, "line"); t.setAttribute("x1", p), t.setAttribute("y1", _), t.setAttribute("x2", p), t.setAttribute("y2", _ + (C + y) / 2 * (m ? 1 : -1)), t.setAttribute("stroke", "black"), t.setAttribute("stroke-width", "0.6"), null != v && null !== v.lineIndicator && void 0 !== v.lineIndicator && v.lineIndicator.attributes.forEach((e => { t.setAttribute(e.name, e.value) })), q.appendChild(t) } const J = document.createElementNS(b, "circle"); return J.setAttribute("cx", p), J.setAttribute("cy", _), J.setAttribute("r", "1.2"), J.setAttribute("fill", "black"), null != v && null !== v.shaft && void 0 !== v.shaft && v.shaft.attributes.forEach((t => { J.setAttribute(t.name, t.value) })), w.appendChild(q), w.appendChild(J), w } const _getComplementaryColor = t => { document.createElement("canvas").getContext("2d").fillStyle = t; const e = colorToRGBArray(t); return `rgb(${255 - e[0]}, ${255 - e[1]}, ${255 - e[2]})` }, colorToRGBArray = t => { const e = document.createElement("canvas"); e.width = e.height = 1; const o = e.getContext("2d"); o.fillStyle = t, o.fillRect(0, 0, 1, 1); const l = o.getImageData(0, 0, 1, 1).data; return [l[0], l[1], l[2]] };