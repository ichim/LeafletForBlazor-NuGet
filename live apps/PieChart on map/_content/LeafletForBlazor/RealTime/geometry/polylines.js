let _measureText = "", _measureStyle = "", _coordinatesAnchor = [0, 0], _measureLines = [], _measureLabels = [], _connectors = [], _rotate = !1; export const _addMeasureText = e => { _measureText = e }; export const _addMeasureStyle = e => { _measureStyle = e }; export const _addMeasureAnchor = e => { _coordinatesAnchor = e }; export const _addRotate = e => { _rotate = e }; export const _deleteAll = e => { _measureLines.forEach((t => { e.removeLayer(t) })), _measureLines = [], _measureLabels.forEach((t => { e.removeLayer(t) })), _measureLabels = [] }; export const _addMeasureArrayToMap = (e, t, a) => { let o = JSON.parse(e); var r = [new L.LatLng(o.start[0], o.start[1]), new L.LatLng(o.end[0], o.end[1])], n = new a.Polyline(r, { color: "black", weight: 1, opacity: 1, smoothFactor: 1 }); n.addTo(t), _measureLines.push(n); let s = n.getCenter(); const c = _getDeg(o); let h = ""; 0 !== c && !0 === _rotate && (h = `rotate:${c}deg`); const i = a.marker(s, { icon: a.divIcon({ iconSize: null, className: "label", html: `<div style = ${_measureStyle};${h} >` + _measureText + "</div>", iconAnchor: JSON.parse(_coordinatesAnchor) }) }).addTo(t); _measureLabels.push(i) }; const _getDeg = e => { if (void 0 === e.start || void 0 === e.end) return 0; const { start: t, end: a } = e; if (Array.isArray(t) && Array.isArray(a) && 2 === t.length && 2 === a.length) { const e = e => e * Math.PI / 180, r = e => 180 * e / Math.PI, n = e(t[0]), s = e(t[1]), c = e(a[0]), h = e(a[1]) - s, i = Math.sin(h) * Math.cos(c), d = Math.cos(n) * Math.sin(c) - Math.sin(n) * Math.cos(c) * Math.cos(h); let l = Math.atan2(i, d); l = (l + 2 * Math.PI) % (2 * Math.PI); return r(l) - 90 * (o = h, Math.abs(o) / o) } var o }, getRadiansBasedOnCorrection = (e, t) => { const a = e => e * Math.PI / 180, o = a(e[0]), r = a(e[1]), n = a(t[0]), s = a(t[1]) - r, c = Math.sin(s) * Math.cos(n), h = Math.cos(o) * Math.sin(n) - Math.sin(o) * Math.cos(n) * Math.cos(s); return Math.atan2(c, h) }; export const _calculateArrowLines = (e, t, a, o, r, n, s) => { function c(e, t, a) { return [e[0] + t, e[1] + a] } function h(e, t, r, n) { const s = Math.atan2(t[1], t[0]), h = s - a, i = s + a; return [[e, c(e, o * Math.cos(h), o * Math.sin(h))], [e, c(e, o * Math.cos(i), o * Math.sin(i))]] } o = _metersToDegrees(o, e[0][0]).latitude; const i = { start: [], end: [] }; if (0 === t || 2 === t) { const t = e[e.length - 1], a = e[e.length - 2], o = [t[0] - a[0], t[1] - a[1]]; i.end = h(t, o) } if (1 === t || 2 === t) { const t = e[0], a = e[1], o = [t[0] - a[0], t[1] - a[1]]; i.start = h(t, o) } var d = new s.Polyline(e, r); if (d.addTo(n), _connectors.push(d), void 0 !== i.start && i.start.length > 0) { var l = new s.Polyline(i.start, r); l.addTo(n), _connectors.push(l) } if (void 0 !== i.end && i.end.length > 0) { var _ = new s.Polyline(i.end, r); _.addTo(n), _connectors.push(_) } return i }; const _metersToDegrees = (e, t) => { const a = 111320; return { latitude: e / a, longitude: e / (a * Math.cos(t * Math.PI / 180)) } }; export const _deleteAllConnector = e => { _connectors.forEach((t => { e.removeLayer(t) })), _connectors = [] };