import { _computingFeliciaLanguage, _contentToChart, _is } from "../helper/felicia.js"; let renderingPointCollection = [], tooltipPointCollection = [], _renderType = "circleMarker", _classAppearanceSymbolsByAttributes = [], _classAppearanceTooltipsByAttributes = [], _defaultCircleMarker = { radius: 15, color: "#22ffff", weight: 4, fillColor: "#28ffff", opacity: .75 }; export const _initializationOfRendering = t => { _renderType = t }; export const _resetOfRendering = () => { _classAppearanceSymbolsByAttributes = [], _classAppearanceTooltipsByAttributes = [] }; export const _settingsOfRendering = (t, e) => { if (0 === t.length) return; const o = t.map((t => t.guid)), i = _classAppearanceSymbolsByAttributes.filter((t => -1 === o.indexOf(t.guid))); _classAppearanceSymbolsByAttributes = [...i, ...t], renderingPointCollection.forEach((t => { const o = _classAppearanceSymbolsByAttributes.filter((e => e.guid === t.guid)), i = renderingPointCollection.filter((e => e.guid === t.guid)); if (0 !== i.length && 0 !== o.length) if (void 0 !== o[0].symbol.iconUrl) { let n = e.icon(o[0].symbol), r = e.marker([t.latitude, t.longitude], { icon: n, rotationAngle: o[0].symbol.rotationAngle, rotationOrigin: o[0].symbol.rotationOrigin }); r.guid = t.guid, __changeToIconFromGroupLayerMethod(i, r, e) } else void 0 !== o[0].symbol.radius && i.map((n => { if (void 0 !== n.marker.options.radius) n.marker.setStyle(o[0].symbol); else { let n = new e.circleMarker([t.latitude, t.longitude], o[0].symbol); n.guid = t.guid, __changeToIconFromGroupLayerMethod(i, n, e) } })) })); const n = _createSymbolsForLegend(_pointsLayersGroup); return { points: _classAppearanceSymbolsByAttributes, symbols: n } }; const _createSymbolsForLegend = t => t.map((t => { const e = Object.values(t._layers), o = e.map((t => t.options)); return { type: t.type, guids: e.map((t => t.guid)), coordinates: e.map((t => [t._latlng.lat, t._latlng.lng])), symbol: 0 !== o.length && void 0 === o[0].icon ? o[0] : null, icon: 0 !== o.length ? void 0 === o[0].icon ? null : o[0].icon.options : null } })), __replaceInToArrayPrototype = (t, e) => t.map((t => t.guid === e.guid ? e : t)), __changeToIconFromGroupLayerMethod = (t, e, o) => { t.forEach((t => { _pointsLayersGroup.forEach((o => o.eachLayer((i => { if (i.guid === t.guid) { o.removeLayer(i); var n = o.addLayer(e); Object.keys(n._layers).map((t => { n._layers[t] })) } })))), renderingPointCollection = renderingPointCollection.map((o => { if (t.guid === o.guid) { let t = o; return t.marker = e, t } return o })) })) }; export const _settingsOfTooltips = (t, e) => { tooltipPointCollection.forEach((t => { t.unbindTooltip() })); const o = t.map((t => _is(t.tooltip.content, "chart"))), i = t.map((t => t.guid)), n = _classAppearanceTooltipsByAttributes.filter((t => -1 === i.indexOf(t.guid))); _classAppearanceTooltipsByAttributes = [...n, ...t], _classAppearanceTooltipsByAttributes = _classAppearanceTooltipsByAttributes.filter((t => "" !== t.tooltip.content)), -1 !== o.indexOf(!0) && e.on("tooltipopen", (t => { _is(t.tooltip._content, "chart") && void 0 !== t && void 0 !== t.tooltip && void 0 !== t.tooltip._content && _contentToChart(t.tooltip._content) })), setTimeout((function () { __settingOrChangeTooltips() }), 2) }; const __settingOrChangeTooltips = () => { _classAppearanceTooltipsByAttributes.forEach((t => { const e = renderingPointCollection.filter((e => e.guid == t.guid)); if (1 === e.length) { const i = e[0]; let n = _computingFeliciaLanguage(i, t.tooltip.content); if (t.tooltip.permanent) { var o = i.marker.bindTooltip(n, { opacity: t.tooltip.opacity, permanent: t.tooltip.permanent }).openTooltip(); tooltipPointCollection.push(o) } else { o = i.marker.bindTooltip(n, { opacity: t.tooltip.opacity, permanent: t.tooltip.permanent }); tooltipPointCollection.push(o) } null !== t.tooltip.content && (_is(t.tooltip.content, "chart") && t.tooltip.permanent) && _contentToChart(n) } })) }, __settingOrChangeTooltip = t => { _classAppearanceTooltipsByAttributes.filter((e => e.guid == t)).forEach((e => { const o = renderingPointCollection.filter((e => e.guid === t)); if (1 === o.length) { const t = o[0]; let i = _computingFeliciaLanguage(t, e.tooltip.content); t.marker.setTooltipContent(i) } })) }; export const _emptyStreamPointCollection = () => { renderingPointCollection = [], tooltipPointCollection = [] }; export const _addPointToCollection = (t, e, o) => { if (!_pointValidateAndMessages(t)) return; let i = new o.marker([t.latitude, t.longitude], { opacity: 1 }); t.guid, t.type, t.value, t.latitude, t.longitude; i.addTo(e) }; export const _settingDisplayCluster = t => { displayCluster = t }; export const _settingClusteringConfig = t => { _clusteringConfiguration = t }; export let _pointsLayersGroup = []; let displayCluster = !1, _clusteringConfiguration = null; export const _addPointsToCollection = (t, e, o, i, n) => { if (e && (renderingPointCollection = [], _pointsLayersGroup = []), !Array.isArray(t)) throw console.warm("is not Array points"), Error("is not Array points"); if (!_pointsValidateAndMessages(t)) throw console.warm("point(s) in Array is/are not valid"), Error("point(s) in Array is/are not valid"); let r = t.map((t => { let e = {}; if ("circleMarker" === _renderType) { const o = _classAppearanceSymbolsByAttributes.filter((e => e.guid === t.guid)); e = new i.circleMarker([t.latitude, t.longitude], 0 !== o.length ? o[0].symbol : _defaultCircleMarker), e.guid = t.guid } else "marker" === _renderType && (e = new i.marker([t.latitude, t.longitude], { opacity: 1 }), e.guid = t.guid); return { guid: t.guid, marker: e, type: t.type, value: t.value, latitude: t.latitude, longitude: t.longitude, timestamp: new Date } })); renderingPointCollection = [...renderingPointCollection, ...r]; const l = Object.values(o._layers).filter((t => void 0 !== t.type)), a = r.filter((t => -1 !== l.map((t => t.type)).indexOf(t.type))), s = r.filter((t => -1 === l.map((t => t.type)).indexOf(t.type))); let p = null; if (0 !== s.length) { let t = null; if (displayCluster) { t = null === _clusteringConfiguration ? i.markerClusterGroup() : i.markerClusterGroup(_clusteringConfiguration), null != n && t.on("clusterclick", (t => { const e = t.layer.getAllChildMarkers().map((t => t.guid)), o = t.layer.getBounds(); let i = { northEast: { latitude: 0, longitude: 0 }, southWest: { latitude: 0, longitude: 0 } }; o.isValid() && (i.northEast.latitude = o._northEast.lat, i.northEast.longitude = o._northEast.lng, i.southWest.latitude = o._southWest.lat, i.southWest.longitude = o._southWest.lng), n.invokeMethodAsync("onClusterClickTrigger", { location: { latitude: t.latlng.lat, longitude: t.latlng.lng }, guids: e, bounds: i }) })); const e = s.map((t => t.marker)); t.addLayers(e) } else t = i.layerGroup(s.map((t => t.marker))); t.type = 0 !== r.length ? r[0].type : "not exist", p = t, _pointsLayersGroup.push(t), t.addTo(o) } return 0 !== a.length && l.map((t => { const e = t.type; a.map((o => { o.type === e && t.addLayer(o.marker), p = t })) })), { layer: p, renderingPointCollection: renderingPointCollection } }; export const _updateAttribute = (t, e, o) => (_updateCollections(t, renderingPointCollection, _pointsLayersGroup, e, o), { symbols: _createSymbolsForLegend(_pointsLayersGroup), layers: _pointsLayersGroup }); const _updateCollections = (t, e, o, i, n) => { let r = e.findIndex((e => e.guid === t.guid)), l = null; if (-1 === r) e.push(t); else { let o = e[r]; if (l = { ...o }, o.type === t.type) e[r].value = t.value; else { let o = e.find((e => e.type === t.type))?.marker || null, i = { ...t, marker: o }; e[r] = i, t = i } } let a = null, s = -1, p = -1, u = 0; for (let e of o) { let o = e._layers, i = 0; for (let n of Object.keys(o)) { if (o[n].guid === t.guid) { a = e, s = u, p = n; break } i++ } if (a) break; u++ } if (a) if (a.type === t.type); else if (delete a._layers[p], 0 === Object.keys(a._layers).length) { let t = 0; for (let e of o) 0 === Object.keys(e._layers).length && o.splice(t, 1), t++; a = null } let d = o.find((e => e.type === t.type)); if (d) d.addLayer(l.marker); else { let e = n.layerGroup([l.marker], t.type); e.type = t.type, o.push(e), e.addTo(i) } }; export const _addPointsOnType = (t, e, o, i) => { if (e && (renderingPointCollection = [], _pointsLayersGroup = []), !Array.isArray(t)) throw console.warm("is not Array points"), Error("is not Array points"); if (!_pointsValidateAndMessages(t)) throw console.warm("point(s) in Array is/are not valid"), Error("point(s) in Array is/are not valid"); let n = t.map((t => { let e = new i.marker([t.latitude, t.longitude], { opacity: 1 }); return { guid: t.guid, marker: e, type: t.type, value: t.value } })); renderingPointCollection = [...renderingPointCollection, ...n]; let r = i.layerGroup(renderingPointCollection.map((t => t.marker))); _pointsLayersGroup.push(r), r.addTo(o) }; export const _clearAllPointsCollection = t => { for (let e of _pointsLayersGroup) t.removeLayer(e); renderingPointCollection = [], tooltipPointCollection = [] }; export const _clearPointsByIdsCollection = (t, e) => { const o = renderingPointCollection.filter((e => -1 !== t.indexOf(e.guid))), i = renderingPointCollection.filter((e => -1 === t.indexOf(e.guid))); o.forEach((t => { e.removeLayer(t.marker) })), renderingPointCollection = i }; export const _removePoints = (t, e) => { }; export const _removeType = (t, e) => { }; export const _movePointFromCollection = (t, e, o) => { if (!_pointValidateAndMessages(t)) return; t.guid; let i = renderingPointCollection.filter((e => e.guid === t.guid)); if (1 !== i.length) throw 0 === i.length ? (console.warn("id(s) does not exist in the Geometric.Points collection"), Error("id(s) does not exist in the Geometric.Points collection")) : (console.warn("Duplicated in the collection of points of Geometric.Points"), Error("Duplicated in the collection of points of Geometric.Points")); { let e = i[0].marker, r = i[0].type, l = i[0].value; t.type === r && t.value === l || console.warn("You cannot change type and/or value using the moveTo method, sorry!"); var n = o.latLng(t.latitude, t.longitude); e.setLatLng(n), e.latitude = t.latitude, e.longitude = t.longitude, e.timestamp = new Date } }; const _pointValidateAndMessages = t => { let e = !0; if (null == t) throw console.warm("Point is not valid"), Error("Point is not valid"); if (void 0 === t.latitude || null === t.latitude) throw console.warm("latiude value is not valid"), Error("latiude value is not valid"); if (void 0 === t.longitude || null === t.longitude) throw console.warm("longitude value is not valid"), Error("longitude value is not valid"); if ("number" != typeof t.latitude || "number" != typeof t.longitude) throw console.warm("longitude and/or latitude value is not a number"), Error("longitude and/or latitude value is not a number"); return e }, _pointsValidateAndMessages = t => { for (let e of t) if (!_pointValidateAndMessages(e)) return !1; return !0 }; export function _asa_trebuie_facuta_scalarea_layerelor(t, e) { let o = 1e4, i = 0; if ("undefined" != typeof symbology && null !== symbology && void 0 !== symbology.scaling && null !== symbology.scaling) { let t = symbology.scaling; void 0 !== t.start_with && null !== t.start_with && (i = parseInt(t.start_with)), void 0 !== t.stop_with && null !== t.stop_with && (o = parseInt(t.stop_with)) } !1 == (0 === i && 1e4 === o) && e.on("zoomend", (function () { parseInt(e.getZoom()) >= i && parseInt(e.getZoom()) <= o ? e.addLayer(layer) : e.removeLayer(layer) })) }