export const _geocodeSearch = (e, r, s, l, t, o) => { if (null == r) return; const { position: d, placeholder: n, useMapBounds: a, title: u, zoomToResult: i, collapseAfterResult: c, expanded: p, allowMultipleResults: g } = r; l.esri.Geocoding.geosearch({ position: (e => { switch (e) { case 0: return "topleft"; case 1: return "topright"; case 2: return "bottomleft"; case 3: return "bottomright" } })(d), placeholder: n, useMapBounds: a, title: u, zoomToResult: i, collapseAfterResult: c, expanded: p, allowMultipleResults: g, providers: [l.esri.Geocoding.arcgisOnlineProvider({ token: s })] }).addTo(t).on("results", (e => { const r = e.results; if (o && 0 !== r.length) { let e = []; e = r.map((e => ({ address: e.text, location: { latitude: e.latlng.lat, longitude: e.latlng.lng }, score: e.score }))), o.invokeMethodAsync("onGeocodeResultTrigger", { results: e }) } })) }; export const _reverseGeocode = (e, r, s, l, t) => { if (null == s) return; let o = s.layerGroup(); o.addTo(l); let d = { matchAddress: null, longLabel: null, shortLabel: null, addressType: null, type: null, placeName: null, addNum: null, address: null, block: null, sector: null, neighborhood: null, district: null, city: null, metroArea: null, subregion: null, region: null, regionAbbreviation: null, territory: null, postal: null, postalExtension: null, countryName: null, countryCode: null, x: null, y: null, inputX: null, inputY: null, structureType: null, structureDetail: null }; l.on("click", (function (e) { o.clearLayers(); s.esri.Geocoding.reverseGeocode({ apikey: r }).latlng(e.latlng).run(((e, r, s) => { e ? console.error("Reverse geocode error:", e) : t && (d = { matchAddress: r.address.Match_addr, longLabel: r.address.LongLabel, shortLabel: r.address.ShortLabel, addressType: r.address.Addr_type, type: r.address.Type, placeName: r.address.PlaceName, addNum: r.address.AddNum, address: r.address.Address, block: r.address.Block, sector: r.address.Sector, neighborhood: r.address.Neighborhood, district: r.address.District, city: r.address.City, metroArea: r.address.MetroArea, subregion: r.address.Subregion, region: r.address.Region, regionAbbreviation: r.address.RegionAbbr, territory: r.address.Territory, postal: r.address.Postal, postalExtension: r.address.PostalExt, countryName: r.address.CntryName, countryCode: r.address.CountryCode, x: r.address.X, y: r.address.Y, inputX: r.address.InputX, inputY: r.address.InputY, structureType: r.address.StrucType, structureDetail: r.address.StrucDet }, t.invokeMethodAsync("onReverseGeocodeResultTrigger", { address: d })) })) })) };